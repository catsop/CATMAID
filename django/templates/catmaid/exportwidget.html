{# -*- mode: espresso; espresso-indent-level: 2; indent-tabs-mode: nil -*- #}
{# vim: set softtabstop=2 shiftwidth=2 tabstop=2 expandtab: #}

{% block content %}

<script type="text/javascript">

  function new_window_with_return( url ) {
    var selectionTables = SelectionTable.prototype.getInstances();
    if (0 === selectionTables.length) {
      alert("Open and populate a Selection Table first!");
      return;
    }
    var dialog = new OptionsDialog("Export NetworkX");
    var choiceST = dialog.appendChoice("Source: ", "neuroml-st",
        selectionTables.map(function(item) { return item.getName(); }),
        selectionTables.map(function(item, i) { return i; }),
        0);

    dialog.onOK = function() {
      jQuery.ajax({
        url: django_url + project.id + url,
        type: "POST",
        dataType: "text",
        data: { skeleton_list: selectionTables[choiceST.selectedIndex].getSelectedSkeletons() },
        success: function (data) {
					var blob = new Blob([data], {type: "text/plain"});
					saveAs(blob, "networkx_graph.json");
        }
      });
    }
    dialog.show();
  };

  function graphexport_nxjson() {
    new_window_with_return( "/graphexport/json" );    
  }

	function graphexport_NeuroML181() {
		var dialog = new OptionsDialog("Export NeuroML Level 3");
		var choice = dialog.appendChoice("Source: ", "neuroml-choice",
				['Neurons in Selection Table and their mutual synapses',
				 'Active neuron and all its input synapses',
				 'Active neuron and input synapses only from neurons in Selection Table'],
				[0, 1, 2],
				0);
		var selectionTables = SelectionTable.prototype.getInstances();
		var choiceST = dialog.appendChoice("Selection table: ", "neuroml-st",
				selectionTables.map(function(item) { return item.getName(); }),
				selectionTables.map(function(item, i) { return i; }),
				0);

		dialog.onOK = function() {
			var post;
			switch (choice.selectedIndex) {
				case 0:
					if (0 === selectionTables.length) {
						alert("Create and fill out a selection table first!");
						return;
					}
					post = {skids: selectionTables[choiceST.selectedIndex].getSelectedSkeletons()};
					if (!post.skids || 0 === post.skids.length) {
						alert("Add first one or more skeletons to the Selection Table!");
						return;
					}
					break;
				case 1:
					post = {skids: [SkeletonAnnotations.getActiveSkeletonId()]};
					if (!post.skids || 0 === post.skids.length) {
						alert("Select a neuron first!");
						return;
					}
					break;
				case 2:
					post = {skids: [SkeletonAnnotations.getActiveSkeletonId()],
					        inputs: selectionTables[choiceST.selectedIndex].getSelectedSkeletons()};
					if (!post.skids || 0 === post.skids.length) {
						alert("Select a neuron first!");
						return;
					} else if (!post.inputs || 0 === post.inputs.length) {
						alert("Add first one or more skeletons to the Selection Table!");
						return;
					}
					break;
			}
			post.mode = choice.selectedIndex;

      jQuery.ajax({
        url: django_url + project.id + "/neuroml/neuroml_level3_v181",
        type: "POST",
        dataType: "text",
        data: post,
        success: function (json) {
					var blob = new Blob([json], {type: "text/plain"});
					saveAs(blob, "circuit.neuroml");
				}});
		};
		dialog.show();
	};

  function export_connectors() {
    // Add skeleton source message and controls
    var dialog = new OptionsDialog("Export connectors");
    dialog.appendMessage('Please select a source from where to get the ' +
        'skeletons of which the connectors should be exported.');
    var select = document.createElement('select');
    SkeletonListSources.createOptions().forEach(function(option, i) {
      select.options.add(option);
      if (option.value === 'Active skeleton') select.selectedIndex = i;
    });
    var label_p = document.createElement('p');
    var label = document.createElement('label');
    label.appendChild(document.createTextNode('Source:'));
    label.appendChild(select);
    label_p.appendChild(label);
    dialog.dialog.appendChild(label_p);

    // Add image dimenension message and controls
    dialog.appendMessage('A set of images will be created around every ' +
        'connecetor. Please specify the size of each image in pixels and ' +
        'how many slices you want to have in each set.');

    // X/Y radius inputs -- default to 100px
    var xy_radius = dialog.appendField('X/Y radius: ', 'c_export_xy_radius', '200');
    var xy_radius_unit = document.createElement('select');
    xy_radius_unit.appendChild(new Option("px", "px", true));
    xy_radius_unit.appendChild(new Option("nm", "nm"));
    xy_radius.parentNode.appendChild(xy_radius_unit);

    // Z radius inputs -- default to 100px
    var z_radius = dialog.appendField('Z radius: ', 'c_export_z_radius', '10');
    var z_radius_unit = document.createElement('select');
    z_radius_unit.appendChild(new Option("sections", "sections", true));
    z_radius_unit.appendChild(new Option("nm", "nm"));
    z_radius.parentNode.appendChild(z_radius_unit);

    // Display total extent
    var extent_info_p = document.createElement('p');
    var extent_info = document.createTextNode('');
    extent_info_p.appendChild(extent_info);
    dialog.dialog.appendChild(extent_info_p);

    // Add checkbox to create sample data for one connector
    var sample_cb_p = document.createElement('p');
    var sample_cb_l = document.createElement('label');
    sample_cb_l.appendChild(document.createTextNode(
        'Create single connector sample: '));
    var sample_cb = document.createElement('input');
    sample_cb.setAttribute('type', 'checkbox');
    sample_cb_l.appendChild(sample_cb);
    sample_cb_p.appendChild(sample_cb_l);
    dialog.dialog.appendChild(sample_cb_p);

    // Updates info text line
    var update_info = function() {
      // Get XY extent
      var xy_extent_px = 2 * dialog.xy_radius;
      var xy_extent_nm = 2 * dialog.xy_radius;
      if (dialog.xy_in_px) {
        // Round pixel extent up, if XY is in nm mode
        xy_extent_nm = Math.round(xy_extent_px * stack.resolution.x);
      } else {
        xy_extent_px = Math.round(xy_extent_nm / stack.resolution.x + 0.5);
      }

      // Get Z extent
      var z_extent_se = 2 * dialog.z_radius;
      var z_extent_nm = 2 * dialog.z_radius;
      if (dialog.z_in_sections) {
        z_extent_nm = Math.round(z_extent_se * stack.resolution.z);
      } else {
        z_extent_se = Math.round(z_extent_nm / stack.resolution.z + 0.5);
      }

      extent_info.nodeValue = 'Output size of one connector: ' +  z_extent_se +
          ' slices of ' + xy_extent_px + ' by ' + xy_extent_px + ' pixels ' +
          '(X/Y: ' + xy_extent_nm + ' nm, Z: ' + z_extent_nm + ' nm).';
    };

    // Add initial data
    dialog.xy_in_px = true;
    dialog.z_in_sections = true;
    dialog.xy_radius = 100;
    dialog.z_radius = 10;

    // Add update handler for XY input
    $(xy_radius).bind('change keyup input', function() {
      if (this.value.match(/[^0-9]/g)) {
        this.value = this.value.replace(/[^0-9]/g, '');
      } else {
        dialog.xy_radius = this.value;
        update_info();
      }
    });
    // Add update handler for Z input
    $(z_radius).bind('change keyup input', function() {
      if (this.value.match(/[^0-9]/g)) {
        this.value = this.value.replace(/[^0-9]/g, '');
      } else {
        dialog.z_radius = this.value;
        update_info();
      }
    });
    // Add update handler for XY unit
    $(xy_radius_unit).change(function() {
      dialog.xy_in_px = $(this).val() == 'px';
      update_info();
    });
    // Add update handler for Z unit
    $(z_radius_unit).change(function() {
      dialog.z_in_sections = $(this).val() == 'sections';
      update_info();
    });

    dialog.show(500, 370, true);
    update_info();
  };

</script>


<h3>Export Graph</h3>

The selected skeletons from the <i>Selection Table</i> are used to extract the subnetwork (in different formats) or
summary statistics.

<ul>

  <li><a id='export-networkx' href='#'><strong>NetworkX JSON graph</strong></a><br />
    Using Python and <a href target='_new' href='http://networkx.github.io/documentation/latest/reference/readwrite.json_graph.html'>NetworkX</a>, you can import the returned file in your Python shell for further analysis.<br />
    <pre>
    import networkx as nx
    from networkx.readwrite import json_graph
    g=json_graph.load(open('my_downloaded_file.json'))
    g.nodes(data=True)
    g.edges(data=True)
    nx.write_graphml( g, 'mynetwork.graphml' )
    </pre></li>

	<li><a id='export-neuroml181' href='#'><strong>NeuroML 1.8.1 (Level 3, NetworkML)</strong></a></br />
	For modeling with <a href="http://www.neuroconstruct.org/">neuroConstruct</a> and then e.g. the <a href="http://www.neuron.yale.edu/neuron/">NEURON</a> simulator.</li>

</ul>

In addition, it is possible to extract only the connectors of the selected
neurons.

<ul>
  <li>
    <a id='export-connector-archive' href='#'>
            <strong>Connector archive</strong></a><br />
    The generated <em>tar.gz</em> archive contains one folder for every
    selected neuron, named after it's ID. Such a folder contains two folders:
    <em>presynaptic</em> and <em>postsynaptic</em> for the respective connector
    types. These in turn contain one folder for each connector, named after
    their ID. The actual images are stored in such a connector folder. They are
    named <em>x_y_z.tiff</em> and encode the image center coordinates in their
    name.
  </li>
</ul>

{% endblock %}
